## 6.1，6.2

### 浏览器是如何渲染html、css、js的

**第一步，构建dom树**

渲染进程将html内容转化为能够读懂的dom结构

**第二步，css样式计算**

1.把css转换为浏览器能理解的结构-stylesheets

2.将样式表中的属性转化为具体数值，比如em、font-weight bold 

3.计算dom树中的每个节点具体样式（样式继承、层叠等）

**第三步，布局阶段**

1.创建布局树，遍历dom数所有可见节点添加到布局树，不可见则忽略

2.布局计算，计算布局树节点的坐标位置。

**第四步，分层阶段，构建图层树**，浏览器的页面实际上被分成了很多图层，图层叠加后合成最终页面

1.拥有层叠上下文的元素会被提升为单独的一层（定位、z值、透明度等）

2.需要剪裁的地方也会被创建为图层

**第五步，图层绘制任务**，渲染引擎会把一个图层拆分出很多小的绘制任务，然后按照顺序组成一个待绘制列表。

**第六步 珊格化操作** 由于页面可能很大，浏览器的合成线程将图层划为图块，图块就是256 * 256或者512 * 512的图像，珊格化就是将图块转换为位图。通常珊格化使用gpu加速生成，gpu是gpu进程的，这里涉及跨进程通信。

**第七步** **页面内容合成及绘制**，所有页面都被珊格化之后，浏览器进程将页面内容绘制到内存中，最终再将内存显示到屏幕上。


### 重排、重绘、合成

重排就是通过修改元素的几何属性，浏览器会重新触发布局，**重排需要更新完整的渲染过程，开销也是最大的**

重绘就是修改元素的绘制属性，浏览器直接进入绘制阶段，省去了布局阶段，所以效率会高一些，但是依然是占用了主线程资源。

合成就是指修改元素不会触发重排和重绘的属性，比如css的transiton实现动画，直接在非主线程执行合成动画操作，没有占用主线程资源。

### 优先队列

正常入，按照优先级出.

实现方法 有很多种，很多语言纳入了标准库，这里学习到的方法是使用min heap

### 算法题：703. 数据流中的第 K 大元素

解法一：数组排序 取第k大

解法二：最小堆 min heap

主要还是用数组排序方法实现的，优先队列的话就使用min heap了

### 搭建有中心webscoket服务器

## 6.3，6.4

### JS变量提升：JS代码的执行流程

**1.编译阶段**

输入js代码 经过编译后，生成**执行上下文（Execution context）和可执行代码（函数调用、变量赋值）。**

- 执行上下文是 JavaScript 执行一段代码时的运行环境（变量环境、词法环境）

- 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；
- 函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。

2.**执行阶段**

JavaScript 引擎会从变量环境中去查找自定义的变量和函数。

### 调用栈、栈溢出

调用栈：js引擎在编译代码，生成全局上下文，和函数内部的上下文，会有多个，它的执行顺序就是栈结构 后进的先执行

栈溢出：浏览器的调用栈是有大小的，入栈的执行上下文超过一定数目，引擎就会报错。

### let const 与var

+ Es使用let const实现块级作用域，变量不会被覆盖

+ 在编译时会进入到执行上下文中的词法环境中，这个也是个栈结构
+ var的创建和初始化被提升，赋值不会被提升。
  let的创建被提升，初始化和赋值不会被提升。
  function的创建、初始化和赋值均会被提升。



### 算法题：242 有效的字母异位词



## 6.5

### 作用域链

先弄明白调用栈、执行上下文、词法环境、变量环境，那么作用域链就简单了。

**当一段代码使用一个变量时，JS引擎会在当前的执行上下文查找该变量，当前执行上下文没查找到就去外部引用去查找，这个外部引用就是跟词法作用域有关系**

### 词法作用域

+ **词法作用域是指作用域由代码声明的位置决定的，所以词法作用域是静态作用域，通过它就可以预测代码在执行过程中如何查找标识符的。**

+ **词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。**

### 闭包

根据词法作用域规则，内部函数总是可以访问其外部函数中声明的变量，即使这个函数已经执行结束了，但是这个变量依然保存在内存中，这些变量的集合就是闭包。



### 闭包是怎么回收的

如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## 6.6

### this的机制

this在大部分情况下都是指向的window

+ **当函数作为对象的方法调用时，函数中的 this 就是该对象；**

+ 全局上下文、函数执行上下文默认指向的window对象
+ 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。

+ **当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；**
+ **嵌套函数中的 this 不会继承外层函数的 this 值。**

### 构造函数new的时候 JS引擎做了哪些事

1. 创建一个空的对象 实例
2. 调用构造函数的call方法，并把该对象作为call的参数传入，当构造函数执行上下文创建时，this就是指向这个实例
3. 执行构造函数
4. 最后return 这个对象

### 算法题：三数之和

核心就是双指针，一次大的循环，指针i，j指针就是i+1，k指针就是末尾，稍微麻烦的点就是判重。