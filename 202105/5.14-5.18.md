### 5.14

#### 前端性能优化

+ css优化

  1.多css合并，减少http请求

   2.精灵图

   3.选择器避免嵌套过深

+ js优化

  1.节流、防抖

  2.长列表滚动到可视区域加载

  3.图片懒加载

  4.使用闭包时在函数结尾手动删除不需要的局部变量，尤其是缓存dom节点情况

+ dom优化

  1.批量添加dom可以使用createElement创建并添加节点，最后一次性增加dom

  2.事件委托

  3.innerHTML代替appedChild

  4.添加class，少使用style，减少重排(回流)

+ 网络优化

  1.减少http请求

  2.利用浏览器缓存，公用依赖包单独打包到一起，避免重复请求。

  3.减小cookie大小，尽量使用localStorage代替

  4.CDN托管静态文件

  5.开启Gzip压缩

+ mapbox gl优化

  1.减少图层的数量，未显示在页面上的图层及时删除

  2.尽量避免使用maker

#### 浏览器内核

内核分为：渲染引擎、js引擎



渲染引擎：负责取得网页内容(html、xml、图像等)，整理讯息（加入css），计算网页的显示方式，然后输出至显示器。

浏览器的内核不同，对于网页的解释也不同，渲染效果也不同。



js引擎：解析和执行js，实现网页动态效果

#### cookies、sessionStorage、localStorage、IndexDB区别

从大小、生命周期、与服务端通信、安全性来讲

cookie是服务端用来标识用户身份的，存在用户本地的数据

cookie安全性时需要注意的

总结：今天主要是刷了三道题，补充了一些基础知识。

### 5.15

今天是周六，加班了，工作了一天，但是内心并不觉得累，因为我觉得我终于狠下心来了，不再安于现状，决定持续学习和产出。  

晚上从8点学习到了10点，主要是制定了学习计划，搜集了一些学习资料，也看了别人是如何学习的，然后补充到了README中。

### 5.17

#### for of是什么，和for in的区别

for of是es6的，for in是es5的

for of 可以实现对iterator对象的遍历，更推荐使用iterator

for of 不会迭代原型链上的数据，for in会

for of主要迭代value值，for in迭代的是键值

#### symbol的数据类型到底是什么

symbol是ES6的类型，它是一切非空字符串的对象key的集合

#### iterator是什么

iterator一般和for of捆绑在一起使用

### 5.18

算法：常见的四种算法时间复杂度

1.二分查找 logn 2.二叉树查找n. 3.排序算法n 4.快排、归并nlogn

实现了一个哈希形式的 两数之和算法

#### 两数之和

### 5.19

#### 扩展运算符...



### 5.23

学习了两种数据结构：数组和链表，两者之间的区别。

时间复杂度一般算是平均的，比如最好的情况o1 最坏情况(O)n，则平均2/n 复杂度为(O)n

数组查找快，修改慢，链表插入快，查找慢。

实现了以下算法：

#### 反转链表 

### 5.24

#### 递归三部曲

1.找终止条件

2.找返回值

3.实现单次的过程

#### 链表元素两两交换



### 5.25 



#### 浏览器的线程和进程

#### fileReader读取pdf，vue-pdf预览、分页加载

#### 网络协议的ip、udp、tcp

IP 负责把数据包送达目的主机。UDP 负责把数据包送达具体应用。而 TCP 保证了数据完整地传输。

#### 一个tcp链接的生命周期

三次握手建立连接，传输阶段数据包校验机制，断开连接四次挥手，

### 5.26

#### 判断链表是否有环

1.哈希、数组遍历 2.快慢指针 3.利用JSON.stringify报错抛出异常 4.标记法

#### http请求流程

#### 缓存流程

#### cookie进行状态管理

### 5.27

#### 有效的括号 堆栈算法

#### 封装canvas组件

#### 从输入URL到页面展示，这中间发生了什么

1.用户输入url回车，地址栏判断是输入内容还是请求url

2.**url请求过程：**浏览器通过进程间通信，把url请求发送给网络进程，网络进程接收到url请求后发起url请求。

​	（1）查本地缓存，有缓存直接返回资源给浏览器进程，没缓存继续下一步。

​	（2）DNS解析获取ip，如果协议是http，则需要建立TLS连接

​    （3）利用ip地址和服务器建立tcp连接，浏览器构建请求头、请求行信息，并把cookie数据附加到请求头中，然后向服务器发送请求。

​	（4）服务器收到请求后，根据请求信息生成数据(响应头，响应行，响应体)，并发给网络进程，然后浏览器解析响应头内容。

​	（5）响应头中如果包括304则重定向，重头开始，读取location字段。

​    （6）根据响应的数据类型content-type，浏览器决定如何处理，比如字节流就下载，html就渲染

3.**准备渲染进程**：如果是同一站点，那么新页面会复用父页面的渲染进程，否则浏览器进程会创建一个新的渲染进程。

渲染进程创建好之后，此时的文档还在网络进程中，并没有提交给渲染进程，而是进入提交文档阶段。

**4.提交文档**：就是浏览器进程将网络进程接收到的html数据交给渲染进程

（1）浏览器进程向渲染进程发起 提交文档消息，渲染进程接收到之后，会和网络进程建立数据传输管道

（2）数据传输完之后，渲染进程会返回 确认提交 给浏览器进程

（4）浏览器进程收到确认提交后，会更新浏览器界面状态，包括安全、url、前进后退历史状态、更新web页面

5.渲染阶段

提交文档过程之后，渲染进程便开始页面解析和子资源加载了，页面加载完成后，渲染进程会通知浏览器进程。

#### 5.28 

#### 移动端requstAnimation 优化touchmove事件



### 5.30

#### 使用双栈实现队列

核心思路是使用双栈，负负得正，int栈负责push 进入，out栈就是这个队列，负责输出

